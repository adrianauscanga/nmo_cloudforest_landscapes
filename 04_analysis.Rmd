---
title: "04_analysis"
author: "Adriana Uscanga"
date: "2/12/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load packages and data

```{r}
library(tidyverse)
library(ggplot2)
library(sf)
library(spdep)
library(leaps)
library(MASS)
library(car)
library(ggpubr)
library(rstatix)
library(corrplot)
library(lme4)
library(fitdistrplus)
library(asbio)
library(RColorBrewer)

load("output/sites_cf3.RData")
load("output/plots_cf3.RData")
load("output/trees_cf3.RData")
```

Add slope and aspect to the data set.

```{r}
#Aspect and Slope from GEE 
aspect <- read_csv("C:/Users/adriana/Documents/OregonPhD/Tesis/ch1/aspect_and_slope/aspect_plots.csv", col_names = F)

slope <- read_csv("C:/Users/adriana/Documents/OregonPhD/Tesis/ch1/aspect_and_slope/slope_plots.csv", col_names = F)

head(aspect)

aspect <- aspect %>%
  transmute(plot_id = as.character(X5),
            lon = as.numeric(X3),
            lat = as.numeric(X4),
            aspect = as.numeric(X2))

head(aspect)

slope <- slope %>%
  transmute(plot_id = as.character(X5),
            lon = as.numeric(X3),
            lat = as.numeric(X4),
            slope = as.numeric(X2))
head(slope)

aspect_slope <- aspect %>%
  left_join(slope, by = c("plot_id", "lon", "lat"))

plots_cf <- plots_cf %>%
  left_join(aspect_slope, by = c("plot_id")) %>%
  select(-lon, -lat) %>%
  relocate(c(aspect, slope), .after = altitude)

plots_cf %>%
  filter(duplicated(longitude), duplicated(latitude)) %>%
  group_by(site) %>%
  summarize(sites = unique(site), plots = unique(plot_id))

plots_cf <- plots_cf %>%
  group_by(site) %>%
  summarize(plot_id = plot_id,
            aspect_first = first(aspect),
            dup = ifelse(duplicated(longitude) & duplicated(latitude), "duplicated", NA),
            aspectdups = ifelse(dup == "duplicated", aspect_first, NA),
            slope_first = first(slope),
            dup_s = ifelse(duplicated(longitude) & duplicated(latitude), "duplicated", NA),
            slopedups = ifelse(dup_s == "duplicated", slope_first, NA)) %>%
  filter(!is.na(dup)) %>%
  select(plot_id, aspectdups, slopedups) %>%
  right_join(plots_cf) %>%
  mutate(aspect = ifelse(is.na(aspect), aspectdups, aspect),
         slope = ifelse(is.na(slope), slopedups, slope)) %>%
  select(-aspectdups, -slopedups)

plots_cf %>%
  filter(is.na(aspect))
#Weird, plot 67878_2 doesn't have aspect and slope, it must have been missing from the GEE feature collection. I'll extract data for this plot and add it.
# aspect = 334.7877502441406
# slope= 34.21200942993164

plots_cf <- plots_cf %>%
  mutate(aspect = ifelse(plot_id == "67878_2", 334.787750, aspect),
         slope = ifelse(plot_id == "67878_2", 34.212009, slope))

# Average aspect and slope by site

calcSE<-function(x){
  x <- x[is.na(x)==F]
  sd(x)/sqrt(length(x))
}

aspect_slope_sites <- plots_cf %>%
  select(site, plot_id, aspect, slope) %>%
  group_by(site) %>%
  summarize(aspect_gee = mean(aspect),
            aspect_se_gee = calcSE(aspect),
            slope_gee = mean(slope),
            slope_se_gee = calcSE(slope)) %>%
  mutate(site = as.character(site))

sites_cf <- sites_cf %>%
  left_join(aspect_slope_sites, by = "site") %>%
  relocate(c("aspect_gee", "aspect_se_gee", "slope_gee", "slope_se_gee"), .after = aspect)
```
Change aspect_gee to categories and compare aspect and slope in dataset

```{r}

sites_cf <- sites_cf %>%
  dplyr::mutate(aspect_gee_c = ifelse(aspect_gee < 45 | aspect_gee > 315, "N",
                                       ifelse(aspect_gee > 135 | aspect < 225, "S",
                                              ifelse(aspect_gee > 225 | aspect_gee < 315, "W",
                                                     ifelse(aspect_gee > 45 | aspect_gee < 135, "E", NA))))) %>%
  relocate(aspect_gee_c, .after = aspect_gee)


```

Site 71213 in sites_cf data set lacks geographic coordinates.
Which are: 17.50506, -96.30769

```{r}
sites_cf <- sites_cf %>%
  mutate(longitude = ifelse(site == "71213", -96.30769, longitude),
         latitude = ifelse(site == "71213", 17.50506, latitude))
```

Add a column with subregions to the data frame.

```{r}
sites_huautla <- read.csv("input/sites_huautla.csv", header = T)
sites_ixtlan <- read.csv("input/sites_ixtlan.csv", header = T)
sites_mixe <- read.csv("input/sites_mixe.csv", header = T)
sites_guevea <- read.csv("input/sites_guevea.csv", header = T)
```

Bind all subregions data sets in one and join to main data set

```{r}
subregions <- rbind(sites_huautla, sites_ixtlan, sites_mixe, sites_guevea)
subregions <- mutate(subregions, subregion = as.character(SUBREGIONE))
subregions <- select(subregions, -SUBREGIONE)
subregions <- subregions %>%
  mutate(site = as.character(site))

sites_cf <- sites_cf %>%
  left_join(subregions, by = "site") %>%
  relocate(subregion, .after = site)

```


# Exploration model: effect of disturbance, succession, and environmental factors

Linear model
or adding random effects:
Generalized Linear Mixed Model (GLMM; when data is not normal)
Linear Mixed Effects Model (when data is normal)
Examples: 
http://mfviz.com/hierarchical-models/
https://ase.tufts.edu/bugs/guide/assets/mixed_model_guide.html
https://esajournals.onlinelibrary.wiley.com/doi/full/10.1002/ecy.3336
https://pjbartlein.github.io/GeogDataAnalysis/lec15.html
https://nlp.stanford.edu/manning/courses/ling289/GLMM.pdf
https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html
https://www.sciencedirect.com/science/article/pii/S0169534709000196
https://ourcodingclub.github.io/tutorials/mixed-models/
https://m-clark.github.io/mixed-models-with-R/random_intercepts.html
https://m-clark.github.io/generalized-additive-models/introduction.html

GLMM book: https://education.illinois.edu/docs/default-source/carolyn-anderson/edpsy587/GLM_GLMM_LMM.pdf

First, know your data. Is it normal? Can it be easily transformed?

https://www.davidzeleny.net/anadat-r/doku.php/en:data_preparation
https://www.datanovia.com/en/lessons/normality-test-in-r/
http://www.css.cornell.edu/faculty/dgr2/_static/files/R_html/Transformations.html


Visual inspection 

```{r}
# First, remove sites with less than 3 plots because they're noisy

sites_cf2 <- sites_cf %>%
  filter(plot_no > 2)

#density plot
ggdensity(sites_cf2$av_agb_site)
ggdensity(sites_cf2$simpson_av_site)

#qqplot
ggqqplot(sites_cf2$av_agb_site)
ggqqplot(sites_cf2$simpson_av_site)
```

Shapiro-Wilk's normality test:

```{r}
shapiro.test(sites_cf2$av_agb_site)
shapiro.test(sites_cf2$simpson_av_site)
shapiro.test(sites_cf2$temp)
shapiro.test(sites_cf2$precip)
shapiro.test(sites_cf2$aspect_gee) # normal p = 0.42
shapiro.test(sites_cf2$slope_gee) # marginally normal p = 0.02
shapiro.test(sites_cf2$mosaic)
shapiro.test(sites_cf2$agriculture)
shapiro.test(sites_cf2$grazing)
shapiro.test(sites_cf2$sp_richness_site_av) # normal p=0.15
shapiro.test(sites_cf2$shannon_av_site) # normal p = 0.60
shapiro.test(sites_cf2$simpson_av_site)

ggdensity(sites_cf2$temp)
ggdensity(sites_cf2$precip)
ggdensity(sites_cf2$aspect_gee)
ggdensity(sites_cf2$slope_gee)
ggdensity(sites_cf2$mosaic)
ggdensity(sites_cf2$agriculture)
ggdensity(sites_cf2$grazing)
ggdensity(sites_cf2$sp_richness_site_av)
ggdensity(sites_cf2$shannon_av_site)
ggdensity(sites_cf2$simpson_av_site)
ggdensity(sites_cf2$av_treedensity_site)
ggdensity(sites_cf2$av_loreys_site)
```
In general, data is not normal (p<0.05). 
Data transformation may solve the problem.

## Multiple regression

```{r}
lm1 <- lm(av_agb_site ~ temp, data = sites_cf2)
summary(lm1)
plot(av_agb_site ~ temp, data = sites_cf2)
abline(lm1)
oldpar <- par(mfrow = c(2, 2))
plot(lm1, which=c(1,2,4,5))

bc1 <- boxcox(lm1)
bc1_power <- bc1$x[which.max(bc1$y)] # 0.1414

# Log Transformation:
lm2 <- lm(log(av_agb_site) ~ temp, data = sites_cf2)
summary(lm2)
plot(log(av_agb_site) ~ temp, data = sites_cf2)
abline(lm2)
oldpar <- par(mfrow = c(2, 2))
plot(lm2, which=c(1,2,4,5))


```

Looking good. Let's add variables to the model

```{r}

lm3 <- lm(log(av_agb_site) ~ temp + precip + altitude + slope_gee + aspect_gee + shannon_av_site + simpson_av_site + sp_richness_site_av + mosaic + agriculture + grazing, data = sites_cf2)
summary(lm3)

# Only mosaic and simpson are significant, slope and ag marginally significant
partial.resid.plot(lm3)

numeric_variables <- sites_cf %>%
  filter(plot_no > 2) %>%
  select(temp, precip, altitude, aspect_gee, slope_gee, sp_richness_site_av, shannon_av_site, simpson_av_site, av_agb_site, mosaic, agriculture, grazing) %>%
  mutate(log_agb = log(av_agb_site))

corr <- cor(drop_na(numeric_variables[,-1]))
corrplot(corr, method = 'ellipse')
corrplot(corr, method = 'number')
plot(numeric_variables)

plot(numeric_variables$slope_gee, numeric_variables$log_agb)
plot(numeric_variables$agriculture, numeric_variables$log_agb)
plot(numeric_variables$grazing, numeric_variables$log_agb)
plot(numeric_variables$mosaic, numeric_variables$log_agb)


```

```{r}
lm3_residuals <- lm3$residuals

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = longitude, y = latitude, shape = subregion)) +
  geom_point(aes(color = lm3$residuals), size = 3) +
  scale_colour_gradient2(low = "#d8b365", mid= "#f5f5f5", high = "#5ab4ac") +
  theme_classic()


```

Test for spatial autocorrelation of residuals:

```{r}

sites_coords <- sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  dplyr::select(longitude, latitude)

#distance neighbors
loc_subs <- cbind(sites_coords$longitude, sites_coords$latitude)
d_subs <- 10 #distance has to be larger than the distance that exists between sites, which is 2.5 km
neighbors_dist <- dnearneigh(loc_subs, 0, d_subs, longlat = T)
str(neighbors_dist)
plot(neighbors_dist, loc_subs)

#Moran test
# spatial autocorrelation of lm3 residuals
moran.test(lm3_residuals, zero.policy=T, 
     nb2listw(neighbors_dist, zero.policy=T, style="W"))

# p = 0.6696 with d= 10
#p = 0.7727 with d= 25
# No spatial autocorrelation!
```

Eliminate some variables from the model using regsubsets function:

```{r}
# regsubsets function

lm4 <- regsubsets(log(av_agb_site) ~ temp + precip + altitude + slope_gee + aspect_gee + shannon_av_site + simpson_av_site + sp_richness_site_av + mosaic + agriculture + grazing, data = sites_cf2)
summary(lm4)

lm4b <- regsubsets(log(av_agb_site) ~ temp + precip + altitude + slope_gee + aspect_gee + shannon_av_site + simpson_av_site + sp_richness_site_av + mosaic + agriculture + grazing + aspect_gee_c, data = sites_cf2)
summary(lm4b)

summary(lm4)
data.frame(
  Adj.R2 = which.max(res.sum$adjr2),
  CP = which.min(res.sum$cp),
  BIC = which.min(res.sum$bic)
)
```
Run again the model, selecting one of the best subsets regression:

```{r}
lm5 <- lm(log(av_agb_site) ~ temp + precip + slope_gee + simpson_av_site + mosaic + agriculture, data = sites_cf2)
summary(lm5)
```
Test for spatial autocorrelation:

```{r}
sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = longitude, y = latitude, shape = subregion)) +
  geom_point(aes(color = lm5$residuals), size = 3) +
  scale_colour_gradient2(low = "#d8b365", mid= "#f5f5f5", high = "#5ab4ac") +
  theme_classic()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = longitude, y = latitude)) +
  geom_point(aes(color = lm5$residuals), size = 3) +
  scale_colour_gradient2(low = "#d8b365", mid= "#f5f5f5", high = "#5ab4ac") +
  theme_classic()

partial.resid.plot(lm5)

oldpar <- par(mfrow = c(2, 2))
plot(lm5, which=c(1,2,4,5))

#Moran test
# spatial autocorrelation of lm3 residuals
moran.test(lm5$residuals, zero.policy=T, 
     nb2listw(neighbors_dist, zero.policy=T, style="W"))
# p = 0.66 with d=10. No spatial autocorrelation detected!
# p = 0.6339 with d=25. No spatial autocorrelation detected!

```

Is there a relationship with some of the categorical variables?

```{r}

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = subregion, y = log(av_agb_site))) +
  geom_boxplot()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = subregion, y = lm5$residuals)) +
  geom_boxplot()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = land_tenure, y = lm5$residuals)) +
  geom_boxplot()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = landform, y = lm5$residuals)) +
  geom_boxplot()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = aspect_gee_c, y = log(av_agb_site))) +
  geom_boxplot()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = aspect_gee_c, y = lm5$residuals)) +
  geom_boxplot()

```

```{r}
# Doesn't look like subregion has a strong effect but I'll run the model with subregion as a random effect just in case

lm6 <- lm(log(av_agb_site) ~ temp + precip + slope_gee + simpson_av_site + sp_richness_site_av + mosaic + agriculture + subregion, data = sites_cf2)
summary(lm6)
```
Subregion is not significant.
Now I'll test aspect:

```{r}
lm6b <- lm(log(av_agb_site) ~ temp + precip + slope_gee + simpson_av_site + sp_richness_site_av + mosaic + agriculture + aspect_gee_c, data = sites_cf2)
summary(lm6b)
```
Aspect doesn't seem to be relevant either.

From these results, it's very obvious that disturbance and succession/patchiness drive the distribution of biomass.
Let's test the relationship between these same variables and tree diversity.

```{r}

lm7 <- lm(shannon_av_site ~ temp + precip + altitude + slope_gee + aspect_gee + av_agb_site + mosaic + agriculture + grazing, data = sites_cf2)
summary(lm7)

lm8 <- lm(simpson_av_site ~ temp + precip + altitude + slope_gee + aspect_gee + av_agb_site + mosaic + agriculture + grazing, data = sites_cf2)
summary(lm8)

lm8b <- lm((simpson_av_site)^2 ~ temp + precip + altitude + slope_gee + aspect_gee + av_agb_site + mosaic + agriculture + grazing, data = sites_cf2)
summary(lm8b)
ggqqplot((sites_cf2$simpson_av_site)^2)

lm9 <- lm(sp_richness_site_av ~ temp + precip + altitude + slope_gee + aspect_gee + av_agb_site + mosaic + agriculture + grazing, data = sites_cf2)
summary(lm9)
```
The trend is a bit different when it comes to diversity. Here, grazing seems to be more important than in past models.
Let's look for the best model

```{r}
# regsubsets function

lm10 <- regsubsets(simpson_av_site ~ temp + precip + altitude + slope_gee + aspect_gee + av_agb_site +  mosaic + agriculture + grazing, data = sites_cf2)
summary(lm10)

lm10b <- regsubsets((simpson_av_site)^2 ~ temp + precip + altitude + slope_gee + aspect_gee + av_agb_site +  mosaic + agriculture + grazing, data = sites_cf2)
summary(lm10b)
```
```{r}
lm11 <- lm(simpson_av_site ~ altitude + slope_gee + av_agb_site +  mosaic + agriculture + grazing, data = sites_cf2)
summary(lm11)

partial.resid.plot(lm11)

lm11b <- lm((simpson_av_site)^2 ~ altitude + aspect_gee + av_agb_site +  mosaic + agriculture + grazing, data = sites_cf2)
summary(lm11b)

partial.resid.plot(lm11b)
```

QQplots 

```{r}
oldpar <- par(mfrow = c(2, 2))
plot(lm11, which=c(1,2,4,5))

oldpar <- par(mfrow = c(2, 2))
plot(lm11b, which=c(1,2,4,5))
```

Relationship with categorical variables

```{r}
sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = subregion, y = simpson_av_site)) +
  geom_boxplot()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = subregion, y = lm11$residuals)) +
  geom_boxplot()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = land_tenure, y = simpson_av_site)) +
  geom_boxplot()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = land_tenure, y = lm11$residuals)) +
  geom_boxplot()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = aspect_gee_c, y = simpson_av_site)) +
  geom_boxplot()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = aspect_gee_c, y = lm11$residuals)) +
  geom_boxplot()
```

```{r}

lm12 <- lm(simpson_av_site ~ altitude + slope_gee + av_agb_site +  mosaic + agriculture + grazing + subregion, data = sites_cf2)
summary(lm12)
```
Map residuals of best model
```{r}

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = longitude, y = latitude)) +
  geom_point(aes(color = lm11$residuals), size = 3) +
  scale_colour_gradient2(low = "#d8b365", mid= "#f5f5f5", high = "#5ab4ac") +
  theme_classic()

#Moran test
# spatial autocorrelation of lm3 residuals
moran.test(lm11$residuals, zero.policy=T, 
     nb2listw(neighbors_dist, zero.policy=T, style="W"))
#no spatial autocorrelation
#p = 0.8025

```

Let's take a look at individual relations

```{r}
# biomass ~ mosaic

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = mosaic, y = log(av_agb_site))) +
  geom_point()


# diversity ~ mosaic

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = mosaic, y = simpson_av_site)) +
  geom_point()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = mosaic, y = sp_richness_site_av)) +
  geom_point()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = mosaic, y = shannon_av_site)) +
  geom_point()

sites_cf %>%
  filter(plot_no > 2) %>%
  filter(!is.na(agriculture)) %>%
  filter(!is.na(grazing)) %>%
  ggplot(aes(x = mosaic, y = altitude)) +
  geom_point()

```

# Environment and AGB

Now let's remove the effect of management filtering out sites with very young forests and disturbance

```{r}

forest <- sites_cf %>%
  filter(plot_no > 2) %>%
  filter(agriculture == 0) %>%
  filter(grazing == 0) %>%
  filter(mosaic > 0.49)

lm13 <- lm(log(av_agb_site) ~ temp + precip + altitude + slope_gee + aspect_gee + simpson_av_site, data = forest)
summary(lm13)

lm14 <- lm(log(av_agb_site) ~ temp + precip + altitude + slope_gee + aspect_gee, data = forest)
summary(lm14)

#lm13 looks better

forest %>%
  ggplot(aes(x = longitude, y = latitude)) +
  geom_point(aes(color = lm13$residuals), size = 3) +
  scale_colour_gradient2(low = "#d8b365", mid= "#f5f5f5", high = "#5ab4ac") +
  theme_classic()

#distance neighbors
loc_subs2 <- cbind(forest$longitude, forest$latitude)
d_subs <- 25 #distance has to be larger than the distance that exists between sites, which is 2.5 km
forest_neighbors_dist <- dnearneigh(loc_subs2, 0, d_subs, longlat = T)
str(forest_neighbors_dist)
plot(forest_neighbors_dist, loc_subs2)

#Moran test
# spatial autocorrelation of lm3 residuals
moran.test(lm13$residuals, zero.policy=T, 
     nb2listw(forest_neighbors_dist, zero.policy=T, style="W"))

# Didn't find spatial autocorrelation in the residuals. I tested d =10, 25, and 50
```

Boxplots:

```{r}
forest %>%
  ggplot(aes(x = subregion, y = log(av_agb_site))) +
  geom_boxplot()

forest %>%
  ggplot(aes(x = subregion, y = lm13$residuals)) +
  geom_boxplot()

forest %>%
  ggplot(aes(x = aspect_gee_c, y = log(av_agb_site))) +
  geom_boxplot()

forest %>%
  ggplot(aes(x = aspect_gee_c, y = lm13$residuals)) +
  geom_boxplot()

lm15 <- lm(log(av_agb_site) ~ temp + precip + altitude + slope_gee + simpson_av_site + aspect_gee_c, data = forest)
summary(lm15)

oldpar <- par(mfrow = c(2, 2))
plot(lm15, which=c(1,2,4,5))


```
How is biomass related to these environmental variables

```{r}

forest %>%
  ggplot(aes(x = temp, y = av_agb_site)) +
  geom_point() +
  geom_smooth(method = 'lm')

forest %>%
  ggplot(aes(x = precip, y = av_agb_site)) +
  geom_point() +
  geom_smooth(method = 'lm')

forest %>%
  ggplot(aes(x = altitude, y = av_agb_site)) +
  geom_point() +
  geom_smooth(method = 'lm')

forest %>%
  filter(plot_no > 3) %>%
  ggplot(aes(x = simpson, y = av_agb_site)) +
  geom_point() +
  geom_smooth(method = 'lm')

forest %>%
  filter(plot_no > 3) %>%
  ggplot(aes(x = sp_richness_site, y = av_agb_site)) +
  geom_point() +
  geom_smooth(method = 'lm')

forest %>%
  ggplot(aes(x = longitude, y = latitude, shape = aspect_gee_c)) +
  geom_point(aes(color = av_agb_site), size = 3) +
  scale_colour_gradient(low = "#f5f5f5", high = "darkgreen") +
  theme_classic()

forest %>%
  ggplot(aes(x = longitude, y = latitude)) +
  geom_point(aes(color = lm15$residuals), size = 3) +
  scale_colour_gradient2(low = "#d8b365", mid= "#f5f5f5", high = "#5ab4ac") +
  theme_classic()

#Moran test
# spatial autocorrelation of lm3 residuals
moran.test(lm15$residuals, zero.policy=T, 
     nb2listw(forest_neighbors_dist, zero.policy=T, style="W"))

# No spatial autocorrelation when d= 50 nor when d=25

```
Let's explore the relationship between temp, precip and biomass

```{r}
forest %>%
  ggplot(aes(x = temp, y = precip, color = av_agb_site, shape = aspect_gee_c)) +
  geom_point(size = 4) +
  scale_colour_gradient(low = "#f5f5f5", high = "darkgreen") +
  theme_classic()

forest %>%
  ggplot(aes(x = temp, y = av_agb_site, color = precip, shape = aspect_gee_c)) +
  geom_point(size = 4) +
  scale_colour_gradient(low = "#f5f5f5", high = "darkblue") +
  theme_classic()

forest %>%
  ggplot(aes(x = precip, y = av_agb_site, color = temp, shape = aspect_gee_c)) +
  geom_point(size = 4) +
  scale_colour_gradient(low = "#f5f5f5", high = "red") +
  theme_classic()

forest %>%
  ggplot(aes(x = precip, y = altitude, color = av_agb_site, shape = aspect_gee_c)) +
  geom_point(size = 4) +
  scale_colour_gradient(low = "#f5f5f5", high = "darkgreen") +
  theme_classic()

forest %>%
  ggplot(aes(x = av_agb_site, y = altitude, color = precip, shape = aspect_gee_c)) +
  geom_point(size = 4) +
  scale_colour_gradient(low = "#f5f5f5", high = "darkblue") +
  theme_classic()
```

```{r}

forest %>%
  ggplot(aes(x = av_loreys_site, y = av_agb_site)) +
  geom_point(size = 4) +
  theme_classic()

forest %>%
  ggplot(aes(x = av_treeheight_site, y = av_agb_site)) +
  geom_point(size = 4) +
  theme_classic()

forest %>%
  ggplot(aes(x = av_basalarea_site, y = av_agb_site)) +
  geom_point(size = 4) +
  theme_classic()

forest %>%
  ggplot(aes(x = tree_no_ave, y = av_agb_site)) +
  geom_point(size = 4) +
  theme_classic()
```

# Environment and diversity

```{r}

forest4p <- forest %>%
  filter(plot_no == 4)

lm16 <- lm(simpson_av_site ~ temp + precip + altitude + slope_gee + aspect_gee, data = forest)
summary(lm16)
```
Diversity didn't show a relationship with these environmental variables.

# RDA

```{r}
sites_cf_4p_nona <- sites_cf %>%
  filter(plot_no >3) %>%
  filter(!is.na(agriculture) | !is.na(grazing))

sites4p_nona <- sites_cf_4p_nona %>%
  select(site)

sites4p_nona_list <- as.list(sites4p_nona)

sp_site4p_nona <- trees_cf %>% # make a table of community data for estimating diversity
  filter(life_form == "Arbol" |
           is.na(life_form)) %>%
  separate(plot_id, c("site", "plot"), sep = "_", remove = F) %>%
  dplyr::group_by(site, species) %>%
  dplyr::summarize(abundance = sum(n())) %>%
  filter(!is.na(species)) %>%
  right_join(sites4p_nona) %>%
  spread(species, abundance, fill = 0) %>%
  column_to_rownames(var = "site")

#Remove spp with abundance = 0 
sp_site4p_nona <- sp_site4p_nona[, which(colSums(sp_site4p_nona) != 0)]

sp_site4p_nona <- sp_site4p_nona[which(rowSums(sp_site4p_nona) != 0), ]

rda1 <- rda(log1p(sp_site4p_nona) ~ sites_cf_4p_nona$mosaic + sites_cf_4p_nona$agriculture + sites_cf_4p_nona$grazing, scale = T)
rda1
summary(rda1)
```
The three variables explain 8.56% of the variance ((5.042+4.050+3.583)/148) = 0.08564189).
PC1 and PC2 together explain 13.455% of the variance.

```{r}
plot(rda1)
ordiplot(rda1, display = 'sites', type = 'text')
ordiplot(rda1, display = 'species', type = 'text')

ordiplot (rda1, display = 'species', choices = c(4,5), type = 'n')
orditorp (rda1, display = 'species', choices = c(4,5), pcol = 'grey', pch = '+')

```
It seems that these three variables are not enough for explaining variation in sp composition.
Let's add temp and precip.

```{r}
rda2 <- rda(log1p(sp_site4p_nona) ~ sites_cf_4p_nona$mosaic + sites_cf_4p_nona$agriculture + sites_cf_4p_nona$grazing + sites_cf_4p_nona$temp + sites_cf_4p_nona$precip, scale = T)
rda2
summary(rda2)
```

Plots

```{r}
plot(rda2)
ordiplot(rda2, display = 'sites', type = 'text')
ordiplot(rda2, display = 'species', type = 'text')

ordiplot (rda2, display = 'species', choices = c(6,7), type = 'n')
orditorp (rda2, display = 'species', choices = c(6,7), pcol = 'grey', pch = '+')

ordiplot (rda2, display = 'species', choices = c(1,2), type = 'n')
orditorp (rda2, display = 'species', choices = c(1,2), pcol = 'grey', pch = '+')
```
Although this rda explains a bit more of variation, the pattern is not clear.

# Forest ~ environment

```{r}

sites_forest4p <- forest4p %>%
  select(site)

sp_site4p_forest <- trees_cf %>% # make a table of community data for estimating diversity
  filter(life_form == "Arbol" |
           is.na(life_form)) %>%
  separate(plot_id, c("site", "plot"), sep = "_", remove = F) %>%
  dplyr::group_by(site, species) %>%
  dplyr::summarize(abundance = sum(n())) %>%
  filter(!is.na(species)) %>%
  right_join(sites_forest4p) %>%
  spread(species, abundance, fill = 0) %>%
  column_to_rownames(var = "site")

#Remove spp with abundance = 0 
sp_site4p_forest <- sp_site4p_forest[, which(colSums(sp_site4p_forest) != 0)]

sp_site4p_forest <- sp_site4p_forest[which(rowSums(sp_site4p_forest) != 0), ]

# RDA

rda3 <- rda(log1p(sp_site4p_forest) ~ forest4p$temp + forest4p$precip + forest4p$altitude + forest4p$slope_gee + forest4p$aspect_gee_c, scale = T)
rda3
summary(rda3)


rda3b <- rda(log1p(sp_site4p_forest) ~ forest4p$temp + forest4p$precip + forest4p$altitude, scale = T)
rda3b
summary(rda3b)

rda3c <- rda(log1p(sp_site4p_forest) ~ forest4p$aspect_gee_c, scale = T)
rda3c
summary(rda3c)
```

Plots

```{r}
plot(rda3)
ordiplot(rda3, display = 'sites', type = 'text')
ordiplot(rda3, display = 'species', type = 'text')

ordiplot (rda3, display = 'species', choices = c(7,8), type = 'n')
orditorp (rda3, display = 'species', choices = c(7,8), pcol = 'grey', pch = '+')
ordiplot(rda3, display = 'sites', choices = c(7,8), type = 'text')

ordiplot (rda3, display = 'species', choices = c(1,2), type = 'n')
orditorp (rda3, display = 'species', choices = c(1,2), pcol = 'grey', pch = '+')

plot(rda3b)
ordiplot(rda3b, display = 'sites', type = 'text')
ordiplot(rda3b, display = 'species', type = 'text')
ordiplot (rda3b, display = 'species', choices = c(1,2), type = 'n')
orditorp (rda3b, display = 'species', choices = c(1,2), pcol = 'grey', pch = '+')
ordiplot (rda3b, display = 'species', choices = c(4,5), type = 'n')
orditorp (rda3b, display = 'species', choices = c(4,5), pcol = 'grey', pch = '+')

plot(rda3c)
ordiplot(rda3c, display = 'sites', type = 'text')
ordiplot(rda3c, display = 'species', type = 'text')
ordiplot(rda3c, display = 'species', choices = c(1,2), type = 'n')
orditorp(rda3c, display = 'species', choices = c(1,2), pcol = 'grey', pch = '+')
ordiplot(rda3c, display = 'species', choices = c(3,4), type = 'n')
orditorp(rda3c, display = 'species', choices = c(3,4), pcol = 'grey', pch = '+')

```

# Composition of only forest

```{r}
pca_forest <- rda(log1p(sp_site4p_forest))
summary(pca_forest)

plot(pca_forest)

ordiplot(pca_forest, display = 'sites', type = 'text')
ordiplot (pca_forest, display = 'species', choices = c(1,2), type = 'n')
orditorp (pca_forest, display = 'species', choices = c(1,2), pcol = 'grey', pch = '+')
ordiplot (pca_forest, display = 'species', choices = c(3,4), type = 'n')
orditorp (pca_forest, display = 'species', choices = c(3,4), pcol = 'grey', pch = '+')

```

Hierarchical cluster with forest sites

```{r}
dis_forest <- vegdist(log1p(sp_site4p_forest), method = "euclidean")
clust_forest <- hclust(dis_forest, method = "ward.D")
plot(clust_forest, cex = 1)
rect.hclust(clust_forest, k = 4)
```
Add relevant info to cluster

```{r}
dend_forest <- as.dendrogram(clust_forest)
dend_forest

# Extract the data (for rectangular lines)
# Type can be "rectangle" or "triangle"
dend_data_f <- dendro_data(dend_forest, type = "rectangle")
names(dend_data_f)

head(dend_data_f$segments)
head(dend_data_f$labels)

labels_info_f <- forest4p %>%
  select(altitude, temp, precip, land_tenure, landform, slope_gee, aspect_gee_c) 

dend_labels_f <- as_tibble(dend_data_f$labels) %>%
  mutate(site = as.character(label)) %>%
  left_join(labels_info_f, by = 'site')

#rect_f <- data.frame(x1=c(0, 28.6, 34.6), x2 = c(28.4, 34.4, 41), y1= c(-0.5, -0.5, -0.5), y2= c(16,16,16))

# Plot line segments and add labels
ggplot(dend_data_f$segments) + 
  geom_segment(aes(x = x, y = y, xend = xend, yend = yend))+
  geom_text(data = dend_labels_f, aes(x, y = -0.7, label = label), hjust = 1, angle = 90, size = 3) +
  ylim(-3, 20) +
  geom_point(data = dend_labels_f, aes(x, y, color = as.factor(aspect_gee_c)), size = 3) +
  #scale_colour_gradient(low = "lightblue", high = "darkblue") +
  #geom_rect(data = rect, mapping= aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), fill = NA, color = "gray70", linetype = 2, size = 0.2) +
  theme_classic()
```

# Tree size contribution to total AGB

```{r}
trees_cf %>%
  ggplot(aes(x= diam_bh)) +
  geom_histogram()

sites <- sites_cf2 %>%
  select(site)

agb_class_site <- trees_cf %>%
  separate(tree_id, c("site", "plot"), sep = "_", remove = F) %>%
  right_join(sites, by = "site") %>%
  filter(status == "Vivo") %>%
  filter(is.na(life_form) | life_form == "Arbol") %>%
  select(site, species, genus, sp, family, diam_bh, agb) %>%
  mutate(diam_class = ifelse(diam_bh <= 10, "1",
                             ifelse(diam_bh > 10 & diam_bh <= 20, "2",
                                    ifelse(diam_bh > 20 & diam_bh<= 30, "3", 
                                           ifelse(diam_bh > 30 & diam_bh <= 40, "4",
                                                  ifelse(diam_bh > 40 & diam_bh <= 50, "5", "6")))))) %>%
  filter(!is.na(agb)) %>%
  group_by(site, diam_class) %>%
  summarise(agb_class_site = sum(agb))

agb_site <- trees_cf %>%
  separate(tree_id, c("site", "plot"), sep = "_", remove = F) %>%
  right_join(sites, by = "site") %>%
  filter(status == "Vivo") %>%
  filter(is.na(life_form) | life_form == "Arbol") %>%
  select(site, species, genus, sp, family, diam_bh, agb) %>%
  mutate(diam_class = ifelse(diam_bh <= 10, "1",
                             ifelse(diam_bh > 10 & diam_bh <= 20, "2",
                                    ifelse(diam_bh > 20 & diam_bh<= 30, "3", 
                                           ifelse(diam_bh > 30 & diam_bh <= 40, "4",
                                                  ifelse(diam_bh > 40 & diam_bh <= 50, "5", "6")))))) %>%
  filter(!is.na(agb)) %>%
  group_by(site) %>%
  summarise(agb_site = sum(agb))  

head(agb_site)
head(agb_class_site)

agb_class_site %>%
  left_join(agb_site, by = "site") %>%
  mutate(agb_prop = agb_class_site/agb_site) %>%
  ggplot(aes(x = diam_class, y = agb_prop)) +
  geom_boxplot()
```

---------------------------------------------------------------------
Data distribution
What probability distribution best fits my data?

'the distribution for a response variable can be
any member of the natural exponential dispersion family. Members of the natural
exponential family for continuous response variables include the normal, gamma,
and inverse Gaussian distributions, and for discrete outcome variables the Poisson, Bernoulli, and binomial distributions.'
'A natural exponential dispersion distribution has two parameters, a natural parameter θ and a dispersion parameter φ . The parameter θ conveys information about the location of the distribution (i.e., mean). When the distribution is expressed in its most basic or canonical form, the natural parameter θ is a function of the mean μ of the distribution. This function is known as the canonical link.'
https://education.illinois.edu/docs/default-source/carolyn-anderson/edpsy587/GLM_GLMM_LMM.pdf

```{r}

agb_test <- sites_cf2$av_agb_site

agb_test_log <- log(sites_cf2$av_agb_site)
agb_test_sr <- sqrt(sites_cf2$av_agb_site)

qqp(agb_test, "norm")
qqp(agb_test_log, "norm")
qqp(agb_test_sr, "norm")

qqp(agb_test, "lnorm")

gamma <- fitdistr(agb_test, "gamma")
qqp(agb_test, "gamma", shape = gamma$estimate[[1]], rate = gamma$estimate[[2]])

inv <- fitdist(agb_test, "invgauss", start = list(mean = 2, shape = 1))
qqp(agb_test, "invgauss", mean = inv$estimate[[1]], shape = inv$estimate[[2]])

```

Diversity

```{r}

simpson_test <- sites_cf2$simpson_av_site
simpson_test_p <- (sites_cf2$simpson_av_site)^2

shapiro.test(simpson_test)

qqp(simpson_test, "norm")
qqp(simpson_test_p, "norm")

```

Let's take a look at the data

```{r}
numeric_variables <- sites_cf %>%
  filter(plot_no > 2) %>%
  select(temp, precip, altitude, aspect_gee, slope_gee, sp_richness_site_av, shannon_av_site, simpson_av_site, av_agb_site, mosaic, agriculture, grazing) 

corr <- cor(drop_na(numeric_variables[,-1]))
corrplot(corr, method = 'ellipse')
corrplot(corr, method = 'number')
plot(numeric_variables)

aspect_agb <- lm(numeric_variables$aspect_gee ~ numeric_variables$av_agb_site, data = numeric_variables)

summary(aspect_agb)
plot(numeric_variables$aspect_gee, numeric_variables$av_agb_site)
abline(aspect_agb)

slope_agb <- lm(numeric_variables$slope_gee ~ numeric_variables$av_agb_site, data = numeric_variables)

summary(slope_agb)
plot(numeric_variables$slope_gee, numeric_variables$av_agb_site)
abline(slope_agb)
```

It seems like aspect and slope are not correlated with the rest of the variables (although empirical data at local scales have shown a correlation between these variables and biomass)

Model

```{r}

lm1 <- lm(numeric_variables$av_agb_site ~ numeric_variables$mosaic)
plot(numeric_variables$av_agb_site ~ numeric_variables$mosaic)
abline(lm1)
summary(lm1)

lm2 <- lm(numeric_variables$av_agb_site ~ numeric_variables$agriculture)
plot(numeric_variables$av_agb_site ~ numeric_variables$agriculture)
abline(lm2)
summary(lm2)

lm3 <- lm(numeric_variables$av_agb_site ~ numeric_variables$grazing)
plot(numeric_variables$av_agb_site ~ numeric_variables$grazing)
abline(lm3)
summary(lm3)

lm4 <- lm(numeric_variables$av_agb_site ~ numeric_variables$sp_richness_site_av)
plot(numeric_variables$av_agb_site ~ numeric_variables$sp_richness_site_av)
abline(lm4)
summary(lm4)

lm5 <- lm(numeric_variables$av_agb_site ~ numeric_variables$shannon_av_site)
plot(numeric_variables$av_agb_site ~ numeric_variables$shannon_av_site)
abline(lm5)
summary(lm5)

lm6 <- lm(numeric_variables$av_agb_site ~ numeric_variables$simpson_av_site)
plot(numeric_variables$av_agb_site ~ numeric_variables$simpson_av_site)
abline(lm6)
summary(lm6)

lm7 <- lm(numeric_variables$av_agb_site ~ numeric_variables$precip)
plot(numeric_variables$av_agb_site ~ numeric_variables$precip)
abline(lm7)
summary(lm7)

lm8 <- lm(numeric_variables$av_agb_site ~ numeric_variables$temp)
plot(numeric_variables$av_agb_site ~ numeric_variables$temp)
abline(lm8)
summary(lm8)
```

# Spatial autocorrelation

Examples: 
- https://www.spatialanalysisonline.com/An%20Introduction%20to%20Spatial%20Data%20Analysis%20in%20R.pdf
- https://gwenantell.com/exploring-spatial-autocorrelation-in-r/
- https://rpubs.com/quarcs-lab/spatial-autocorrelation
- Bart's class: https://pjbartlein.github.io/GeogDataAnalysis/lec13.html

Get distance-neighbor matrix  and plot network of sites.

```{r}

#distance neighbors
loc <- cbind(sites_cf$longitude, sites_cf$latitude)
d <- 10 #distance has to be larger than the distance that exists between sites, which is 2.5 km
sites_neighbors_dist <- dnearneigh(loc, 0, d, longlat = T)
str(sites_neighbors_dist)
plot(sites_neighbors_dist, loc)

plot(loc)

```



Moran test

```{r}
# spatial autocorrelation of dependent variable (AGB and Simpson)
moran.test(sites_cf$av_agb_site, zero.policy=T, 
     nb2listw(sites_neighbors_dist, zero.policy=T, style="W"))


```
*25km apart*:
	Moran I test under randomisation

data:  sites_cf$av_agb_site  
weights: nb2listw(sites_neighbors_dist, zero.policy = T, style = "W")    

Moran I statistic standard deviate = 3.2834, p-value =
0.0005128
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.106909344      -0.009433962       0.001255547
      

*20 km apart:*
Moran I test under randomisation

data:  sites_cf$av_agb_site  
weights: nb2listw(sites_neighbors_dist, zero.policy = T, style = "W")    

Moran I statistic standard deviate = 2.7158, p-value =
0.003305
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.105901804      -0.009433962       0.001803527 

*15 km apart:*
Moran I test under randomisation

data:  sites_cf$av_agb_site  
weights: nb2listw(sites_neighbors_dist, zero.policy = T, style = "W")  n reduced by no-neighbour observations
  

Moran I statistic standard deviate = 1.9438, p-value =
0.02596
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.098077538      -0.009523810       0.003064303 

*10 km apart:*
Moran I test under randomisation

data:  sites_cf$av_agb_site  
weights: nb2listw(sites_neighbors_dist, zero.policy = T, style = "W")  n reduced by no-neighbour observations
  

Moran I statistic standard deviate = 1.1365, p-value =
0.1279
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.084236860      -0.010000000       0.006875416 

      
Run the analysis with sites that have at least 3 plots, to reduce some noise

```{r}
sites_subset <- sites_cf %>%
  filter(plot_no > 2)

#plot variables
plot(sites_subset[,c(10:14,18,20,34)]) 
plot(sites_subset[,c(12,13,18,20,34,40,48)])

#distance neighbors
loc_subs <- cbind(sites_subset$longitude, sites_subset$latitude)
d_subs <- 10 #distance has to be larger than the distance that exists between sites, which is 2.5 km
sites_subset_neighbors_dist <- dnearneigh(loc_subs, 0, d_subs, longlat = T)
str(sites_subset_neighbors_dist)
plot(sites_subset_neighbors_dist, loc_subs)

#Moran test
# spatial autocorrelation of dependent variable (AGB and Simpson)
moran.test(sites_subset$av_agb_site, zero.policy=T, 
     nb2listw(sites_subset_neighbors_dist, zero.policy=T, style="W"))

# Moran test with distance = 10
#Moran I statistic standard deviate = 2.9615, p-value = 0.001531
#alternative hypothesis: greater
#sample estimates:
#Moran I statistic       Expectation          Variance 
#       0.38509221       -0.01754386        0.01848425 

## Distance = 20
d_subs2 <- 20 #distance has to be larger than the distance that exists between sites, which is 2.5 km
sites_subset_neighbors_dist2 <- dnearneigh(loc_subs, 0, d_subs2, longlat = T)

plot(sites_subset_neighbors_dist2, loc_subs)

#Moran test
# spatial autocorrelation of dependent variable (AGB and Simpson)
moran.test(sites_subset$av_agb_site, zero.policy=T, 
     nb2listw(sites_subset_neighbors_dist2, zero.policy=T, style="W"))

#Moran I statistic standard deviate = 4.5796, p-value = 2.329e-06
#alternative hypothesis: greater
#sample estimates:
#Moran I statistic       Expectation          Variance 
#      0.317644918      -0.015151515       0.005280796 


## Distance = 5

d_subs3 <- 5 #distance has to be larger than the distance that exists between sites, which is 2.5 km
sites_subset_neighbors_dist3 <- dnearneigh(loc_subs, 0, d_subs3, longlat = T)

plot(sites_subset_neighbors_dist3, loc_subs)

#Moran test
# spatial autocorrelation of dependent variable (AGB and Simpson)
moran.test(sites_subset$av_agb_site, zero.policy=T, 
     nb2listw(sites_subset_neighbors_dist3, zero.policy=T, style="W"))

#Moran I statistic standard deviate = 0.47578, p-value = 0.3171
#alternative hypothesis: greater
#sample estimates:
#Moran I statistic       Expectation          Variance 
#       0.07981275       -0.03703704        0.06031799 
```

Let's explore distances between 5 and 10:

```{r}
#distance neighbors
loc_subs <- cbind(sites_subset$longitude, sites_subset$latitude)
d_subs <- 5 #distance has to be larger than the distance that exists between sites, which is 2.5 km
sites_subset_neighbors_dist <- dnearneigh(loc_subs, 0, d_subs, longlat = T)
str(sites_subset_neighbors_dist)
plot(sites_subset_neighbors_dist, loc_subs)

#Moran test
# spatial autocorrelation of dependent variable (AGB and Simpson)
moran.test(sites_subset$av_agb_site, zero.policy=T, 
     nb2listw(sites_subset_neighbors_dist, zero.policy=T, style="W"))

#10
#Moran I statistic standard deviate = 2.9615, p-value =0.001531
#alternative hypothesis: greater
#sample estimates:
#Moran I statistic       Expectation          Variance 
#       0.38509221       -0.01754386        0.01848425 

#9
#Moran I statistic standard deviate = 2.5088, p-value = 0.006056
#alternative hypothesis: greater
#sample estimates:
#Moran I statistic       Expectation          Variance 
#       0.34235874       -0.01923077        0.02077221 

#8
#Moran I statistic standard deviate = 2.5088, p-value =
#0.006056
#alternative hypothesis: greater
#sample estimates:
#Moran I statistic       Expectation          Variance 
#       0.34235874       -0.01923077        0.02077221

#7
#Moran I statistic standard deviate = 2.032, p-value =0.02108
#alternative hypothesis: greater
#sample estimates:
#Moran I statistic       Expectation          Variance 
#       0.33073160       -0.02325581        0.03034737

#6
#Moran I statistic standard deviate = 0.79832, p-value =0.2123
#alternative hypothesis: greater
#sample estimates:
#Moran I statistic       Expectation          Variance 
#       0.12408276       -0.02500000        0.03487432

#5
#Moran I statistic standard deviate = 0.47578, p-value =0.3171
#alternative hypothesis: greater
#sample estimates:
#Moran I statistic       Expectation          Variance 
#       0.07981275       -0.03703704        0.06031799
```


Moran test shows that there's spatial autocorrelation among sites that are at least 7 km apart when only sites with more than 2 plots are considered (closer than that, the neighborhoods are too small). When all sites are considered, Moran test is not significant at 10 km.
To account for this spatial autocorrelation, I'll cluster the data in subregions.
Fortunately, Toledo-Aceves et al (2011) already divided the NMO region in smaller subregions, which fit pretty well with the network of neighbors using d=10km.

First, let's conduct a Moran's I test with a diversity index.

```{r}
#distance neighbors
loc_subs <- cbind(sites_subset$longitude, sites_subset$latitude)
d_subs <- 10 #distance has to be larger than the distance that exists between sites, which is 2.5 km
sites_subset_neighbors_dist <- dnearneigh(loc_subs, 0, d_subs, longlat = T)
str(sites_subset_neighbors_dist)
plot(sites_subset_neighbors_dist, loc_subs)

#Moran test
# spatial autocorrelation of dependent variable (AGB and Simpson)
moran.test(sites_subset$simpson_av_site, zero.policy=T, 
     nb2listw(sites_subset_neighbors_dist, zero.policy=T, style="W"))
```
It's not significant in neighborhoods of 10 km.